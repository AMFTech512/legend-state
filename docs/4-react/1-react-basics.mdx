There are three ways to consume observables in React:
1. Accessing observable makes the component automatically track them
2. Rendering them directly
3. `useComputed` to get individual values

## Access an observable

Accessing observables within any React component automatically makes it track the accessed observables for changes. Just call `enableLegendStateReact()` once at the beginning of your application to enable it.


```jsx
import { enableLegendStateReact } from "@legendapp/state/react"

enableLegendStateReact()

const state = observable({ count: 0 })

// No HOC or selector needed
function Component() {
    // Accessing state automatically makes this
    // component track changes to re-render
    const count = state.count;

    // Magic ðŸ¦„
    return <div>{count}</div>
}
```

### Example

```jsx
import { observable } from "@legendapp/state"

const state = observable({ settings: { theme: 'dark' }, messages: [{ id: 0, text: 'hi' }] })

function Component {
    // Automatically tracks for changes:
    // [settings.theme, state.messages (shallow)]

    return (
        <div>
            <div>Theme: {state.settings.theme}</div>
            <div>Messages:</div>
            <div>
                {state.messages.map(m => <Message id={m.get().id} message={m} />)}
            </div>
        </div>
    )
})
```

## Rendering directly

Render an observable `string` or `number` straight into React and it will automatically be extracted as a separate memoized component with its own tracking context.

Just call `obs()` on an observable primitive to get its observable.

```jsx
<div>Count: {state.count.obs()}</div>
```

### Example

<Example name="Primitive">
```jsx
import { observable } from "@legendapp/state"

const state = observable({ count: 0 })

function ComponentNormal() {
    // Rendering the primitive: the component tracks it
    const renderCount = ++useRef(0).current
    return (
        <div>Renders: {renderCount}</div>
        <div>Normal: {state.count}</div>
    )
}
function ComponentDirect() {
    // Rendering the observable: tracks in an isolated element
    const renderCount = ++useRef(0).current
    return (
        <div>Renders: {renderCount}</div>
        <div>Tracked: {state.count.obs()}</div>
    )
}
```
</Example>

See [fine-grained reactivity](../fine-grained-reactivity/#1-render-an-observable-directly) for more details.

## useComputed

`useComputed` is a hook that computes a value and automatically listen to any observables accessed while computing, and only re-renders if the computed value changes.

Props:
- `selector`: Computation function that listens to observables accessed while running
- `alwaysUpdate` (optional): Always re-render regardless of return value

```jsx
import { useComputed } from "@legendapp/state/react"

const isSelected = useComputed(() => id === state.selected)
```

### Example

```jsx
import { observable } from "@legendapp/state"
import { useComputed } from "@legendapp/state/react"

const state = observable({ selected: 1 })

const Component = ({ id }) => {
    const isSelected = useComputed(() => id === state.selected)
    // Only re-renders if the value of (id === state.selected) changes

    return <div>Selected: {isSelected}</div>
}
```

See [Tracking](../tracking) for details about how `useComputed` automatically tracks changes
